# 5. 탐색트리
저장된 데이터에 대해 탐색, 삽입, 삭제, 갱신 등의 연산을 수행할 수 있는 자료구조를 Dictionary라고 일컫는다.   
배열, 연결리스트는 사전이지만 각 연산을 수행하는데 선형시간이 소요된다는 단점이 있고, 스택이나 큐는 특정 작업에 적합한 자료구조이나 사전 자료구조로 볼 수 없다.   
탐색트리는 리스트 자료구조의 수행시간을 향상시키기 위한 트리 형태의 자료구조이다.

## 5.1 이진탐색트리
이진탐색은 정렬된 데이터의 중간에 위치한 항목을 기준으로 데이터를 두 부분으로 나누어 가며 특정 항목을 찾는 탐색방법이다. 연결리스트의 중간 노드를 중심으로 좌측 노드들은
이전 노드를 가리키도록 하고, 우측 노드는 이후 노드를 가리키도록 한다. 그리고 연결리스트의 중간 노드를 위로 끌어당기면 트리 형식이 된다.

__이진탐색트리는 이진 탐색을 수행하기 위해 단순연결리스트를 변형시킨 자료구조이다__

이진탐색트리의 특징으로 트리를 '중위순회'하면 정렬된 출력을 얻는다는 것이다. 이진탐색트리는 가장 기본적인 트리 형태의 자료구조이고, 데이터베이스 등의 대용량 데이터 저장의 기본 개념으로도 활용된다.

이진탐색트리의 조건: 각 노드 n의 키 값이 n의 왼쪽 서브트리에 있는 노드들의 키값들보다 크고, n의 오른쪽 서브트리에 있는 노드들의 키값들보다 작다.

1) 이진탐색트리 구현시 노드 객체는 id, name, 왼쪽자식, 오른쪽자식 필드를 갖는다.
2) 탐색연산 : 탐색은 항상 루트노드에서 시작하고, 탐색하고자 하는 key와 루트노드의 id를 비교하는 것으로 탐색을 시작한다. (key < id 이면 왼쪽 서브트리에서 key를 찾고, key > id 이면 오른쪽 서브트리에서 key를 찾는다. 탐색 성공시 해당노드의 value인 name을 리턴)
3) 삽입연산 : 탐색 연산과 거의 동일하다. 탐색 연산 마지막에서 null이 반환되는 상황에서 null을 반환하는 대신 새로운 노드를 생성하고 노드를 부모노드와 연결하면 된다.
4) 삭제연산 : 탐색 과정을 거친뒤 삭제할 노드를 찾고, 삭제 노드의 부모노드와 자식노드들을 연결해 주어야 한다. 이를 위해 삭제 노드가 자식이 없는 경우 case0, 자식이 하나인 경우 case1, 자식이 둘인 경우 case2로 나누어 delete 연산을 수행
```
public void delete(Key k) {
    root = delete(root, k);
}

public Node delete(Node n, Key k) {
    if(n == null) return null;
    int t = n.getKey().compareTo(k);
    
    if(t > 0) n.setLeft(delete(n.getLeft()), k));       //왼쪽 자식으로 이동
    else if(t < 0) n.setRight(delete(n.getRight(), k);  //오른쪽 자식으로 이동
    //삭제할 노드 발경
    else {
        if(n.getRight() == null) return n.getLeft();
        if(n.getLeft() == null) return n.getRight();
        Node target = n;
        n = min(target.getRight());
        n.setRight(deleteMin(target.getRight()));
        n.setLeft(target.getLeft());
    }
    return n;
}
```
<img src="img/case0.jpeg" width="500px">

<img src="img/case1.jpeg" width="500px">

<img src="img/case2.jpeg" width="500px">

__최솟값 찾기__ : 루트노드로부터 왼쪽 자식노드를 따라 내려가며 null을 만났을 때 null의 부모노드가 가진 id가 최솟값이다.
```
public Key min() {
    if(root == null) return null;
    return (Key) min(root).getKey();
}

//인자로 전달받은 노드가 null이 아닌한 계속 왼쪽 자식을 인자로 넘겨 min 메소드를 재귀호출
private Node min(Node n) {
    if(n.getLeft() == null) return n;   //null이면 부모 노드를 리턴한다.
    return min(n.getLeft());            //null을 만날때까지 재귀호출
}
```

__최솟값 삭제__ : 최솟값 x를 찾은 뒤, x의 부모노드 p와 x의 오른쪽 자식노드 c를 연결하면 된다. 이때 c가 null이라도 자식으로 삼아 연결한다.
```
public void deleteMin() {
    if(root == null) System.out.println("empty 트리");
    root = deleteMin(root);
}

public Node deleteMin(Node n) {
    if(n.getLeft() == null) return n.getRight();
    n.setLeft(deleteMin(n.getLeft()));
    return n;
}
```

<img src="img/searchTree_del.jpeg" width="500px">