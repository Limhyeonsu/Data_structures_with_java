# 1. 자료구조를 배우기 위한 준비
## 1.1 자료구조와 추상데이터 타입
자료구조는 일련의 동일한 타입의 데이터를 정돈하여 저장한 구성체를 의미한다. 정돈하는 목적은 프로그램에서 저장하는 데이터에 대해 탐색, 삽입, 삭제 등의 연산을 효율적으로 수행하기 위해서다.   
따라서 자료구조를 설계할 때는 데이터와 데이터에 관련된 연산들을 함께 고려하여 설계해야 한다.

추상데이터타입은 데이터와 그 데이터에 대한 추상적인 연산들로써 구성된다. '추상'의 의미는 연산을 구체적으로 어떻게 구현하여야 한다는 세부 명세를 포함하고 있지 않다는 의미다.   
__자료구조는 추상데이터타입을 구체적으로 구현한 것을 의미한다.__

추상데이터타입은 객체지향 언어의 인터페이스 개념과 유사하고, 인터페이스를 클래스로 구현한 것을 자료구조라고 할 수 있다.   
실제로 자주 사용되는 자료구조로는 1차원배열, 선형자료구조(리스트, 스택, 큐, 트리, 해시테이블, 그래프 등)를 들 수 있다.   
추상데이터타입에 기반하여 효율적인 자료구조를 만들어야만 효율적인 알고리즘의 설계가 가능하다.

## 1.2 수행시간의 분석
자료구조의 효율성은 연산의 수행시간으로 측정할 수 있다. 수행시간 측정 방식은 알고리즘의 성능을 측정하는 방식과 동일하고, 알고리즘의 성능은 __수행시간을 나타내는 '시간복잡도'__ ,
수행되는 동안 __사용되는 메모리 공간의 크기를 나타내는 '공간복잡도'에__ 기반하여 분석한다.

알고리즘의 시간복잡도는 알고리즘이 실행되는 동안에 사용된 기본적인 연산 횟수를 입력 크기의 함수로 나타낸다. 기본 연산이란 데이터간의 크기 비교, 데이터 읽기 및 갱신, 숫자 계산 등과 같은 단순한 연산을 의미한다.

[수행시간 분석]
* 최악경우 분석 : 어떤 입력이 주어지더라도 알고리즘의 수행시간이 얼마 이상은 넘지 않는다라는 상한의 의미를 갖는다.(일반적으로 알고리즘의 수행시간은 최악경우 분석으로 표현s)
* 평균경우 분석 : 입력의 확률 분포를 가정하여 분석, 일반적으로 균등분포를 가정한다.(입력이 무작위로 주어진다고 가정)
* 최선경우 분석 : 가장 빠른 수행시간을 분석
* 상각분석 : 일련의 연산을 수행 후 총 연산 횟수를 합하여 이를 연산 횟수로 나누어 수행시간을 분석하는 방법

수행시간 예)   
등교시간이 집에서 지하철까지 5분, 지하철타고 학교까지 20분, 강의실까지 걸어서 10분 소요시   
1)최선경우 : 5분 + 20분 + 10분 = 35분   
2)최악경우 : 지하철을 타려는 순간 지하철을 놓친 경우(10분 추가)5분 + 10분 + 20분 + 10분 = 45분   
3)평균시간 : 최악과 최선의 중간 40분   
4)상각분석 : 한 번의 등교시간이 아닌 한 학기 동안의 등교 시간을 분석, 한 학기 동안 학교에 가는데 소요된 시간을 모두 합해서 학교에 간 횟수로 나눈 값을 1회 등교시간으로 본다.

**상각분석은 입력의 확률분포에 대한 가정이 필요없다는 장점을 가지며, 최악경우분석보다 매우 정확한 분석이 가능하다. 상각분석은 연산 수행시간이 대부분 짧게 소요되지만 가끔씩 길게 소요되는 경우에 사용할 수 있다.

## 1.3 수행시간의 점근 표기법
수행시간은 알고리즘이 수행하는 기본 연산 횟수를 입력 크기에 대한 함수로 표현한 것이고, 점근 표기법이 사용된다.
* Big-Oh 표기법 : 점근적 상한 <img src="https://i.imgur.com/b1q2NZr.png" width="500px;">
* Big-Omega 표기법 :점근적 하한 <img src="https://cdn.kastatic.org/ka-perseus-images/c02e6916d15bacae7a936381af8c6e5a0068f4fd.png" width="500px;">
* Theta 표기법 : 동일한 증가율 <img src="https://cdn.kastatic.org/ka-perseus-images/c14a48f24cae3fd563cb3627ee2a74f56c0bcef6.png" width="500px">

알고리즘 수행시간은 주로 Big-Oh 표기를 사용한다.

## 1.4 자바 언어에 대한 기본적인 지식
데이터를 저장하고 있는 객체들을 위한 자료구조는 별도의 클래스로 구현하며, 자료구조 객체 내부에 저장되어 있는 객체를 탐색하고, 삭제하며, 새 객체를 삽입하는 등의 연산을 수행하는 메소드들도 자료구조의 클래스 내에 정의한다.
* 배열 : `동일한 타입`의 원소들이 `연속적인` 메모리 공간에 할당되어 있는 자료구조
* if문 : 조건문
* for문, while문 : 반복문 
* Comparable : 인터페이스로써 객체의 하나의 멤버만을 기준으로 객체들을 정렬할 때 사용된다. comparaTo 메소드만을 갖는다. 
* Comparator : 동일한 타입의 객체들을 여러 개의 멤버를 기준으로 나열할 수 있게 해주고, compare 메소드만을 갖는다.
* import문 : 이미 정의되어 있는 클래스를 사용하기 위한 선언문

## 1.5 순환(재귀호출)
메소드의 실행 과정 중 스스로를 호출하는 것, 주의할 점은 무한 호출을 방지해야 한다는 점이다.
```
//1) 재귀호출을 이용한 팩토리얼
public class Factorial {
    public static int factorial(int n) {
        if(n <= 1)
            return 1;
        else
            return n * factorial(n-1);
    }
    
    public static void main(String[] args) {
        int result;
        result = factorial(4);
        System.out.println(result);
    }
}

//2) 반복문을 이용한 팩토리얼
public class Factorial {
    public static void main(String[] args) {
        int n = 4;
        int result = 1;
        for(int i=1; i <= n; i++)
            result = result * i;
        System.out.println(result);
    }
}
```
반복문을 이용한 계산은 메소드 호출로 인한 시스템 스택을 사용하지 않으므로 순환을 이용한 계산보다 간단하고, 메모리도 적게 사용한다.

**메소드의 마지막 부분에서 순환하는 것을 꼬리 순환이라고 하며, 꼬리 순환은 반복문으로 변환하는 것이 수행 속도와 메모리 사용 측면에서 효율적이다.

순환 프로그램은 가독성은 높일 수 있으나 시스템 스택을 사용하기 때문에 메모리 사용 측면에서 비효율적이다.